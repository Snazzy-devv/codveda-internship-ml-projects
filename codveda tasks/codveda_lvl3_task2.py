# -*- coding: utf-8 -*-
"""Codveda lvl3 task2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AmRiq3NhitUzR4PsxZ3CMea6X00cXOz4
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from sklearn.datasets import make_classification
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score, precision_score, recall_score, roc_auc_score, roc_curve

from google.colab import files

uploaded = files.upload()

from google.colab import drive
drive.mount('/content/drive')

train_df = pd.read_csv("churn-bigml-80.csv")
test_df  = pd.read_csv("churn-bigml-20.csv")

print("Training shape:", train_df.shape)
print("Testing shape:", test_df.shape)

train_df.head(), test_df.head()

print(train_df.columns)

X_train = train_df.drop('Churn', axis=1)
y_train = train_df['Churn']

X_test  = test_df.drop('Churn', axis=1)
y_test  = test_df['Churn']

X_train = pd.get_dummies(X_train, drop_first=True)
X_test  = pd.get_dummies(X_test, drop_first=True)

X_train, X_test = X_train.align(X_test, join='left', axis=1, fill_value=0)

from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()

X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled  = scaler.transform(X_test)

from sklearn.svm import SVC

svm_linear = SVC(kernel='linear', probability=True, random_state=42)
svm_linear.fit(X_train_scaled, y_train)

svm_rbf = SVC(kernel='rbf', probability=True, random_state=42)
svm_rbf.fit(X_train_scaled, y_train)

from sklearn.metrics import accuracy_score, precision_score, recall_score, roc_auc_score

def evaluate(model, X, y):
    y_pred = model.predict(X)
    y_prob = model.predict_proba(X)[:, 1]

    return {
        "Accuracy": accuracy_score(y, y_pred),
        "Precision": precision_score(y, y_pred),
        "Recall": recall_score(y, y_pred),
        "AUC": roc_auc_score(y, y_prob)
    }

print("Linear SVM:", evaluate(svm_linear, X_test_scaled, y_test))
print("RBF SVM:", evaluate(svm_rbf, X_test_scaled, y_test))

svm_linear = SVC(
    kernel='linear',
    probability=True,
    class_weight='balanced',
    random_state=42
)

svm_rbf = SVC(
    kernel='rbf',
    probability=True,
    class_weight='balanced',
    random_state=42
)

svm_linear.fit(X_train_scaled, y_train)
svm_rbf.fit(X_train_scaled, y_train)

print("Linear SVM (Balanced):", evaluate(svm_linear, X_test_scaled, y_test))
print("RBF SVM (Balanced):", evaluate(svm_rbf, X_test_scaled, y_test))

from sklearn.metrics import confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt

##Confusion Matrix & Heatmap
cm = confusion_matrix(y_test, svm_rbf.predict(X_test_scaled))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('RBF SVM Confusion Matrix')
plt.show()

##ROC Curve Comparison
from sklearn.metrics import roc_curve
y_prob_linear = svm_linear.predict_proba(X_test_scaled)[:,1]
y_prob_rbf = svm_rbf.predict_proba(X_test_scaled)[:,1]

fpr_lin, tpr_lin, _ = roc_curve(y_test, y_prob_linear)
fpr_rbf, tpr_rbf, _ = roc_curve(y_test, y_prob_rbf)

plt.plot(fpr_lin, tpr_lin, label='Linear SVM')
plt.plot(fpr_rbf, tpr_rbf, label='RBF SVM')
plt.plot([0,1],[0,1],'--', color='gray')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Curve Comparison')
plt.legend()
plt.show()